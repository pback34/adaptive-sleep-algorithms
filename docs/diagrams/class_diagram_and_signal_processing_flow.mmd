classDiagram
    %% Core Abstract & Base Classes
    class SignalData {
        <<abstract>>
        +metadata: Union[TimeSeriesMetadata, FeatureMetadata]
        +_data: Any
        +get_data() Any
        +apply_operation(operation_name, inplace, **parameters) SignalData
        +registry: Dict~str, Tuple~
    }

    class TimeSeriesSignal {
        <<abstract>>
        +metadata: TimeSeriesMetadata
        +get_sampling_rate() float
        +snap_to_grid(target_period, ref_time) DataFrame
        +resample_to_rate(new_rate, target_period, ref_time) DataFrame
        +reindex_to_grid(grid_index, method) DataFrame
    }

    class Feature {
        +metadata: FeatureMetadata
        +_data: DataFrame
        +get_data() DataFrame
    }

    %% Metadata Classes
    class TimeSeriesMetadata {
        +signal_id: str
        +name: str
        +signal_type: SignalType
        +sample_rate: str
        +units: Dict[str, Unit]
        +start_time: datetime
        +end_time: datetime
        +operations: List[OperationInfo]
        +derived_from: List[Tuple]
        +sensor_type: SensorType
        +sensor_model: SensorModel
        +body_position: BodyPosition
        +source_files: List[str]
    }

    class FeatureMetadata {
        +feature_id: str
        +name: str
        +feature_type: FeatureType
        +epoch_window_length: Timedelta
        +epoch_step_size: Timedelta
        +operations: List[OperationInfo]
        +feature_names: List[str]
        +source_signal_keys: List[str]
        +source_signal_ids: List[str]
        +sensor_type: SensorType
        +sensor_model: SensorModel
        +body_position: BodyPosition
    }

    class CollectionMetadata {
        +collection_id: str
        +subject_id: str
        +session_id: str
        +start_datetime: datetime
        +end_datetime: datetime
        +timezone: str
        +index_config: List[str]
        +feature_index_config: List[str]
        +epoch_grid_config: Dict[str, str]
    }

    class OperationInfo {
        +operation_name: str
        +parameters: Dict[str, Any]
    }

    class MetadataHandler {
        +initialize_time_series_metadata(**kwargs) TimeSeriesMetadata
        +initialize_feature_metadata(**kwargs) FeatureMetadata
        +update_metadata(metadata, **kwargs)
        +set_name(metadata, name, key)
        +record_operation(metadata, operation_name, parameters)
    }

    %% Signal Classes
    class PPGSignal {
        +signal_type = SignalType.PPG
        +required_columns = ['value']
    }

    class AccelerometerSignal {
        +signal_type = SignalType.ACCELEROMETER
        +required_columns = ['x', 'y', 'z']
        +compute_magnitude() MagnitudeSignal
        +compute_angle() AngleSignal
    }

    class HeartRateSignal {
        +signal_type = SignalType.HEART_RATE
        +required_columns = ['hr']
        +get_hrv_stats() Dict
    }

    class MagnitudeSignal {
        +signal_type = SignalType.ACCELEROMETER
        +required_columns = ['magnitude']
    }

    class AngleSignal {
        +signal_type = SignalType.ACCELEROMETER
        +required_columns = ['pitch', 'roll']
    }

    class EEGSleepStageSignal {
        +signal_type = SignalType.EEG_SLEEP_STAGE
        +required_columns = ['sleep_stage']
        +get_stage_distribution() Series
    }

    %% Collection Class
    class SignalCollection {
        +time_series_signals: Dict~str, TimeSeriesSignal~
        +features: Dict~str, Feature~
        +metadata: CollectionMetadata
        +metadata_handler: MetadataHandler
        +grid_index: DatetimeIndex
        +epoch_grid_index: DatetimeIndex
        +_aligned_dataframe: DataFrame
        +_combined_feature_matrix: DataFrame
        +_repository: SignalRepository
        +_query_service: SignalQueryService
        +_metadata_manager: MetadataManager
        +_alignment_grid_service: AlignmentGridService
        +_epoch_grid_service: EpochGridService
        +_alignment_executor: AlignmentExecutor
        +_combination_service: SignalCombinationService
        +_operation_executor: OperationExecutor
        +_import_service: DataImportService
        +_summary_reporter: SignalSummaryReporter
        +add_time_series_signal(key, signal)
        +add_feature(key, feature)
        +add_signal_with_base_name(base_name, signal): str
        +get_signal(key) Union[TimeSeriesSignal, Feature]
        +get_signals(input_spec, signal_type, feature_type, criteria, base_name) List~Union[TimeSeriesSignal, Feature]~
        +apply_multi_signal_operation(operation_name, signal_keys, parameters) Union[TimeSeriesSignal, Feature]
        +apply_operation(operation_name, **parameters) Any
        +generate_alignment_grid()
        +generate_epoch_grid()
        +apply_grid_alignment()
        +combine_aligned_signals()
        +combine_features()
        +summarize_signals()
        +import_signals_from_source(importer_instance, source, spec): List[TimeSeriesSignal]
    }

    %% Importer Classes
    class SignalImporter {
        <<abstract>>
        +import_signal(source, signal_type) SignalData
        +import_signals(source, signal_type) List~SignalData~
    }

    class CSVImporterBase {
        <<abstract>>
        +_parse_csv(source) DataFrame
        +_validate_columns(data, signal_type)
        +_extract_metadata(data, source, signal_type) Dict
    }

    class PolarCSVImporter {
        +config: Dict
        +_parse_csv(source) DataFrame
        +_extract_metadata(data, source, signal_type) Dict
    }

    class EnchantedWaveImporter {
        +config: Dict
        +_parse_csv(source) DataFrame
        +_extract_metadata(data, source, signal_type) Dict
    }

    class MergingImporter {
        +config: Dict
        +file_pattern: str
        +time_column: str
        +sort_by: str
        +import_signal(directory, signal_type) SignalData
    }

    %% Export Class
    class ExportModule {
        +collection: SignalCollection
        +SUPPORTED_FORMATS: List~str~
        +export(formats, output_dir, content)
        +_export_excel(output_dir, content)
        +_export_csv(output_dir, content)
    }

    %% Repository Layer
    class SignalRepository {
        +time_series_signals: Dict~str, TimeSeriesSignal~
        +features: Dict~str, Feature~
        +metadata_handler: MetadataHandler
        +collection_timezone: str
        +add_time_series_signal(key, signal)
        +add_feature(key, feature)
        +add_signal_with_base_name(base_name, signal): str
        +get_time_series_signal(key): TimeSeriesSignal
        +get_feature(key): Feature
        +get_by_key(key): Union[TimeSeriesSignal, Feature]
    }

    %% Service Layer
    class SignalQueryService {
        +repository: SignalRepository
        +get_signals(...) List
        +_matches_criteria(signal, criteria): bool
    }

    class MetadataManager {
        +metadata_handler: MetadataHandler
        +update_time_series_metadata(signal, metadata_spec)
        +update_feature_metadata(feature, metadata_spec)
    }

    class AlignmentGridService {
        +repository: SignalRepository
        +generate_alignment_grid(target_sample_rate): AlignmentGridState
        +get_target_sample_rate(user_specified): float
        +get_reference_time(target_period): pd.Timestamp
    }

    class EpochGridService {
        +repository: SignalRepository
        +collection_metadata: CollectionMetadata
        +generate_epoch_grid(start_time, end_time): EpochGridState
    }

    class AlignmentExecutor {
        +repository: SignalRepository
        +alignment_grid_service: AlignmentGridService
        +apply_grid_alignment(method, signals_to_align): int
    }

    class SignalCombinationService {
        +metadata: CollectionMetadata
        +alignment_state: AlignmentGridState
        +epoch_state: EpochGridState
        +combine_aligned_signals(time_series_signals): CombinationResult
        +combine_features(features, inputs, feature_index_config): CombinationResult
    }

    class OperationExecutor {
        +collection_op_registry: Dict
        +multi_signal_registry: Dict
        +epoch_state: EpochGridState
        +apply_collection_operation(operation_name, collection_instance, **parameters): Any
        +apply_multi_signal_operation(operation_name, input_signal_keys, parameters)
    }

    class DataImportService {
        +add_time_series_signal: Callable
        +import_signals_from_source(importer_instance, source, spec): List[TimeSeriesSignal]
        +add_imported_signals(signals, base_name, start_index): List[str]
    }

    class SignalSummaryReporter {
        +summarize_signals(time_series_signals, features, fields_to_include, print_summary): DataFrame
    }

    %% State Models
    class AlignmentGridState {
        +target_rate: float
        +reference_time: pd.Timestamp
        +grid_index: DatetimeIndex
        +merge_tolerance: pd.Timedelta
        +is_calculated: bool
    }

    class EpochGridState {
        +epoch_grid_index: DatetimeIndex
        +window_length: pd.Timedelta
        +step_size: pd.Timedelta
        +is_calculated: bool
    }

    class CombinationResult {
        +dataframe: DataFrame
        +params: Dict~str, Any~
    }

    %% Workflow Executor
    class WorkflowExecutor {
        +container: SignalCollection
        +strict_validation: bool
        +data_dir: str
        +execute_workflow(workflow_config)
        +execute_step(step)
        +_process_import_section(import_specs)
        +_process_export_section(export_config)
        +_process_visualization_section(vis_specs)
    }

    %% Feature Extraction Module
    class FeatureExtraction {
        <<module>>
        +compute_feature_statistics(signals: List[TimeSeriesSignal], epoch_grid_index, parameters, global_window, global_step) Feature
        +compute_sleep_stage_mode(signals: List[TimeSeriesSignal], epoch_grid_index, parameters, global_window, global_step) Feature
        -_compute_basic_stats(segment: DataFrame, aggregations: List): Dict
    }

    %% Visualization Classes
    class VisualizerBase {
        <<abstract>>
        +create_figure(**kwargs) Any
        +add_line_plot(figure, x, y, **kwargs) Any
        +add_scatter_plot(figure, x, y, **kwargs) Any
        +add_categorical_regions(figure, starts, ends, cats, cat_map, **kwargs) List[Any]
        +visualize_hypnogram(figure, signal, **kwargs) Any
        +create_hypnogram_plot(signal, **kwargs) Any
        +create_time_series_plot(signal, **kwargs) Any
        +visualize_signal(signal, **kwargs) Any
        +visualize_collection(collection, signals, layout, **kwargs) Any
        +create_from_config(config, collection) Any
        +process_visualization_config(config, collection)
        +save(figure, filename, format, **kwargs)
        +show(figure)
    }

    class BokehVisualizer {
        +create_figure(**kwargs) Any
        +add_line_plot(figure, x, y, **kwargs) Any
        +add_scatter_plot(figure, x, y, **kwargs) Any
        +add_categorical_regions(figure, starts, ends, cats, cat_map, **kwargs) List[Any]
        +visualize_hypnogram(figure, signal, **kwargs) Any
        +save(figure, filename, format, **kwargs)
        +show(figure)
    }

    class PlotlyVisualizer {
        +create_figure(**kwargs) Any
        +add_line_plot(figure, x, y, **kwargs) Any
        +add_scatter_plot(figure, x, y, **kwargs) Any
        +add_categorical_regions(figure, starts, ends, cats, cat_map, **kwargs) List[Any]
        +visualize_hypnogram(figure, signal, **kwargs) Any
        +save(figure, filename, format, **kwargs)
        +show(figure)
    }

    %% Algorithms
    class SleepStagingAlgorithm {
        <<abstract>>
        +name: str
        +version: str
        +fit(features, labels)
        +predict(features): Feature
        +evaluate(features, labels): Dict
    }

    class RandomForestSleepStaging {
        +model: RandomForestClassifier
        +feature_columns: List[str]
        +fit(features, labels)
        +predict(features): Feature
        +save(path)
        +load(path)
    }

    %% Class Relationships
    SignalData <|-- TimeSeriesSignal
    TimeSeriesSignal <|-- PPGSignal
    TimeSeriesSignal <|-- AccelerometerSignal
    TimeSeriesSignal <|-- HeartRateSignal
    TimeSeriesSignal <|-- MagnitudeSignal
    TimeSeriesSignal <|-- AngleSignal
    TimeSeriesSignal <|-- EEGSleepStageSignal

    SignalImporter <|-- CSVImporterBase
    CSVImporterBase <|-- PolarCSVImporter
    CSVImporterBase <|-- EnchantedWaveImporter
    SignalImporter <|-- MergingImporter

    VisualizerBase <|-- BokehVisualizer
    VisualizerBase <|-- PlotlyVisualizer

    SignalCollection o-- "1" CollectionMetadata : has >
    SignalCollection o-- "1" MetadataHandler : uses >
    SignalRepository o-- "*" TimeSeriesSignal : stores >
    SignalRepository o-- "*" Feature : stores >

    TimeSeriesSignal o-- "1" TimeSeriesMetadata : has >
    Feature o-- "1" FeatureMetadata : has >

    OperationInfo --* TimeSeriesMetadata : included in operations list
    OperationInfo --* FeatureMetadata : included in operations list

    %% SignalCollection uses Services
    SignalCollection "1" o-- "1" SignalRepository : uses >
    SignalCollection "1" o-- "1" SignalQueryService : uses >
    SignalCollection "1" o-- "1" MetadataManager : uses >
    SignalCollection "1" o-- "1" AlignmentGridService : uses >
    SignalCollection "1" o-- "1" EpochGridService : uses >
    SignalCollection "1" o-- "1" AlignmentExecutor : uses >
    SignalCollection "1" o-- "1" SignalCombinationService : uses >
    SignalCollection "1" o-- "1" OperationExecutor : uses >
    SignalCollection "1" o-- "1" DataImportService : uses >
    SignalCollection "1" o-- "1" SignalSummaryReporter : uses >

    %% Services use Repository and State
    SignalQueryService --> SignalRepository : queries >
    AlignmentGridService --> SignalRepository : accesses >
    EpochGridService --> SignalRepository : accesses >
    AlignmentExecutor --> SignalRepository : modifies >
    AlignmentExecutor --> AlignmentGridService : uses >
    SignalCombinationService --> AlignmentGridState : uses >
    SignalCombinationService --> EpochGridState : uses >
    OperationExecutor --> EpochGridState : uses >
    MetadataManager --> MetadataHandler : uses >

    %% Services produce State Models
    AlignmentGridService ..> AlignmentGridState : creates >
    EpochGridService ..> EpochGridState : creates >
    SignalCombinationService ..> CombinationResult : creates >

    ExportModule --> SignalCollection : exports
    WorkflowExecutor --> SignalCollection : orchestrates
    WorkflowExecutor --> VisualizerBase : uses >
    VisualizerBase --> SignalCollection : visualizes >

    %% Processing Flow
    AccelerometerSignal ..> MagnitudeSignal : creates
    AccelerometerSignal ..> AngleSignal : creates
    SignalImporter ..> TimeSeriesSignal : produces
    WorkflowExecutor ..> SignalImporter : uses
    WorkflowExecutor ..> ExportModule : uses
    SignalCollection ..> FeatureExtraction : uses >
    FeatureExtraction ..> Feature : produces >
    Feature .. TimeSeriesSignal : derived from >
    SleepStagingAlgorithm <|-- RandomForestSleepStaging
    RandomForestSleepStaging ..> Feature : processes >
    RandomForestSleepStaging ..> Feature : produces >
