classDiagram
    %% Base Classes
    class SignalData {
        <<abstract>>
        +metadata: Union[TimeSeriesMetadata, FeatureMetadata]
        +get_data(): Any
        +apply_operation(operation_name, inplace, **parameters): SignalData
        +clear_data()
        #_regenerate_data(): bool
    }
    
    %% TimeSeriesSignal and Metadata
    class TimeSeriesSignal {
        <<abstract>>
        +metadata: TimeSeriesMetadata
        +get_sampling_rate(): float
        +get_data(): DataFrame
        +apply_operation(operation_name, inplace, **parameters): SignalData
        +filter_lowpass(cutoff: float): DataFrame
        +snap_to_grid(target_period, ref_time): DataFrame
        +resample_to_rate(new_rate, target_period, ref_time, method): DataFrame
    }
    
    class TimeSeriesMetadata {
        +signal_id: str
        +name: str
        +signal_type: SignalType
        +sample_rate: str
        +units: Dict[str, Unit]
        +start_time: datetime
        +end_time: datetime
        +operations: List[OperationInfo]
        +derived_from: List[Tuple]
        +sensor_type: SensorType
        +sensor_model: SensorModel
        +body_position: BodyPosition
        +source_files: List[str]
        +temporary: bool
    }
    
    %% Feature Class and Metadata
    class Feature {
        +metadata: FeatureMetadata
        +_data: DataFrame
        +get_data(): DataFrame
        +__repr__(): str
    }
    
    class FeatureMetadata {
        +feature_id: str
        +name: str
        +feature_type: FeatureType
        +epoch_window_length: Timedelta
        +epoch_step_size: Timedelta
        +operations: List[OperationInfo]
        +feature_names: List[str]
        +source_signal_keys: List[str]
        +source_signal_ids: List[str]
        +sensor_type: SensorType
        +sensor_model: SensorModel
        +body_position: BodyPosition
    }
    
    %% Feature Types
    class FeatureType {
        <<enum>>
        STATISTICAL
        CATEGORICAL_MODE
        SPECTRAL
        CORRELATION
    }
    
    %% Signal Implementations
    class HeartRateSignal {
        +signal_type = SignalType.HEART_RATE
        +required_columns = ["value"]
    }
    
    class AccelerometerSignal {
        +signal_type = SignalType.ACCELEROMETER
        +required_columns = ["x", "y", "z"]
    }
    
    class EEGSleepStageSignal {
        +signal_type = SignalType.EEG_SLEEP_STAGE
        +required_columns = ["sleep_stage"]
        +get_stage_distribution(): Series
    }
    
    %% Collection & Operations
    class SignalCollection {
        +time_series_signals: Dict[str, TimeSeriesSignal]
        +features: Dict[str, Feature]
        +metadata: CollectionMetadata
        +metadata_handler: MetadataHandler
        +grid_index: DatetimeIndex
        +epoch_grid_index: DatetimeIndex
        +global_epoch_window_length: Timedelta
        +global_epoch_step_size: Timedelta
        +_aligned_dataframe: DataFrame
        +_combined_feature_matrix: DataFrame
        +_alignment_params_calculated: bool
        +_epoch_grid_calculated: bool
        +_repository: SignalRepository
        +_query_service: SignalQueryService
        +_metadata_manager: MetadataManager
        +_alignment_grid_service: AlignmentGridService
        +_epoch_grid_service: EpochGridService
        +_alignment_executor: AlignmentExecutor
        +_combination_service: SignalCombinationService
        +_operation_executor: OperationExecutor
        +_import_service: DataImportService
        +_summary_reporter: SignalSummaryReporter
        +add_time_series_signal(key, signal)
        +add_feature(key, feature)
        +add_signal_with_base_name(base_name, signal): str
        +get_time_series_signal(key): TimeSeriesSignal
        +get_feature(key): Feature
        +get_signal(key): Union[TimeSeriesSignal, Feature]
        +get_signals(input_spec, signal_type, feature_type, criteria, base_name): List[Union[TimeSeriesSignal, Feature]]
        +apply_multi_signal_operation(operation_name, signal_keys, parameters): Union[TimeSeriesSignal, Feature]
        +apply_operation(operation_name, **parameters): Any
        +generate_alignment_grid(): SignalCollection
        +generate_epoch_grid(): SignalCollection
        +apply_grid_alignment(method: str)
        +combine_aligned_signals()
        +align_and_combine_signals()
        +combine_features(inputs: List[str], feature_index_config: List[str])
        +summarize_signals(): DataFrame
        +import_signals_from_source(importer_instance, source, spec): List[TimeSeriesSignal]
        +add_imported_signals(signals, base_name, start_index): List[str]
    }
    
    class CollectionMetadata {
        +collection_id: str
        +subject_id: str
        +session_id: str
        +start_datetime: datetime
        +end_datetime: datetime
        +timezone: str
        +index_config: List[str]
        +feature_index_config: List[str]
        +epoch_grid_config: Dict[str, str]
    }
    
    class OperationInfo {
        +operation_name: str
        +parameters: Dict[str, Any]
    }
    
    class MetadataHandler {
        +initialize_time_series_metadata(**kwargs): TimeSeriesMetadata
        +initialize_feature_metadata(**kwargs): FeatureMetadata
        +update_metadata(metadata, **kwargs)
        +set_name(metadata, name, key)
        +record_operation(metadata, operation_name, parameters)
    }

    %% Repository Layer
    class SignalRepository {
        +time_series_signals: Dict[str, TimeSeriesSignal]
        +features: Dict[str, Feature]
        +metadata_handler: MetadataHandler
        +collection_timezone: str
        +add_time_series_signal(key, signal)
        +add_feature(key, feature)
        +add_signal_with_base_name(base_name, signal): str
        +get_time_series_signal(key): TimeSeriesSignal
        +get_feature(key): Feature
        +get_by_key(key): Union[TimeSeriesSignal, Feature]
    }

    %% Service Classes
    class SignalQueryService {
        +repository: SignalRepository
        +get_signals(input_spec, signal_type, feature_type, criteria, base_name): List
        +_process_enum_criteria(criteria_dict): Dict
        +_matches_criteria(signal, criteria): bool
    }

    class MetadataManager {
        +metadata_handler: MetadataHandler
        +update_time_series_metadata(signal, metadata_spec)
        +update_feature_metadata(feature, metadata_spec)
        +validate_time_series_metadata_spec(index_fields)
    }

    class AlignmentGridService {
        +repository: SignalRepository
        +generate_alignment_grid(target_sample_rate): AlignmentGridState
        +get_target_sample_rate(user_specified): float
        +get_reference_time(target_period): pd.Timestamp
    }

    class EpochGridService {
        +repository: SignalRepository
        +collection_metadata: CollectionMetadata
        +generate_epoch_grid(start_time, end_time): EpochGridState
    }

    class AlignmentExecutor {
        +repository: SignalRepository
        +alignment_grid_service: AlignmentGridService
        +apply_grid_alignment(method, signals_to_align): int
    }

    class SignalCombinationService {
        +metadata: CollectionMetadata
        +alignment_state: AlignmentGridState
        +epoch_state: EpochGridState
        +combine_aligned_signals(time_series_signals): CombinationResult
        +combine_features(features, inputs, feature_index_config): CombinationResult
    }

    class OperationExecutor {
        +collection_op_registry: Dict
        +multi_signal_registry: Dict
        +epoch_state: EpochGridState
        +apply_collection_operation(operation_name, collection_instance, **parameters): Any
        +apply_multi_signal_operation(operation_name, input_signal_keys, parameters): Union[TimeSeriesSignal, Feature]
    }

    class DataImportService {
        +add_time_series_signal: Callable
        +import_signals_from_source(importer_instance, source, spec): List[TimeSeriesSignal]
        +add_imported_signals(signals, base_name, start_index): List[str]
    }

    class SignalSummaryReporter {
        +summarize_signals(time_series_signals, features, fields_to_include, print_summary): DataFrame
        +get_summary_dataframe(): DataFrame
    }

    %% State Models
    class AlignmentGridState {
        +target_rate: float
        +reference_time: pd.Timestamp
        +grid_index: DatetimeIndex
        +merge_tolerance: pd.Timedelta
        +is_calculated: bool
    }

    class EpochGridState {
        +epoch_grid_index: DatetimeIndex
        +window_length: pd.Timedelta
        +step_size: pd.Timedelta
        +is_calculated: bool
    }

    class CombinationResult {
        +dataframe: DataFrame
        +params: Dict[str, Any]
    }

    %% Workflow Execution
    class WorkflowExecutor {
        +container: SignalCollection
        +strict_validation: bool
        +data_dir: str
        +execute_workflow(workflow_config: Dict)
        +execute_step(step: Dict)
        -_process_import_section(import_specs: List)
        -_process_export_section(export_config: List)
        -_process_visualization_section(vis_specs: List)
    }
    
    %% Feature Extraction
    class FeatureExtraction {
        <<module>>
        +compute_feature_statistics(signals: List[TimeSeriesSignal], epoch_grid_index: DatetimeIndex, parameters: Dict, global_window, global_step): Feature
        +compute_sleep_stage_mode(signals: List[TimeSeriesSignal], epoch_grid_index: DatetimeIndex, parameters: Dict, global_window, global_step): Feature
        -_compute_basic_stats(segment: DataFrame, aggregations: List): Dict
    }
    
    %% Visualization
    class VisualizerBase {
        <<abstract>>
        +visualize_signal(signal: Union[TimeSeriesSignal, Feature], **kwargs): Any
        +visualize_collection(collection: SignalCollection, signals: List[str], layout: str, **kwargs): Any
        +create_time_series_plot(signal: TimeSeriesSignal, **kwargs): Any
        +create_hypnogram_plot(signal: EEGSleepStageSignal, **kwargs): Any
    }

    %% Algorithms
    class SleepStagingAlgorithm {
        <<abstract>>
        +name: str
        +version: str
        +fit(features, labels)
        +predict(features): Feature
        +evaluate(features, labels): Dict
    }

    class RandomForestSleepStaging {
        +model: RandomForestClassifier
        +feature_columns: List[str]
        +fit(features, labels)
        +predict(features): Feature
        +save(path)
        +load(path)
    }

    %% Relationships - Inheritance
    SignalData <|-- TimeSeriesSignal
    TimeSeriesSignal <|-- HeartRateSignal
    TimeSeriesSignal <|-- AccelerometerSignal
    TimeSeriesSignal <|-- EEGSleepStageSignal
    SleepStagingAlgorithm <|-- RandomForestSleepStaging

    %% Relationships - Composition
    TimeSeriesSignal "1" *-- "1" TimeSeriesMetadata : has
    Feature "1" *-- "1" FeatureMetadata : has
    SignalCollection "1" *-- "1" CollectionMetadata : has
    SignalCollection "1" *-- "1" MetadataHandler : uses
    SignalRepository "1" *-- "0..*" TimeSeriesSignal : stores
    SignalRepository "1" *-- "0..*" Feature : stores

    OperationInfo --* TimeSeriesMetadata : included in operations list
    OperationInfo --* FeatureMetadata : included in operations list

    %% Relationships - SignalCollection uses Services
    SignalCollection "1" o-- "1" SignalRepository : uses
    SignalCollection "1" o-- "1" SignalQueryService : uses
    SignalCollection "1" o-- "1" MetadataManager : uses
    SignalCollection "1" o-- "1" AlignmentGridService : uses
    SignalCollection "1" o-- "1" EpochGridService : uses
    SignalCollection "1" o-- "1" AlignmentExecutor : uses
    SignalCollection "1" o-- "1" SignalCombinationService : uses
    SignalCollection "1" o-- "1" OperationExecutor : uses
    SignalCollection "1" o-- "1" DataImportService : uses
    SignalCollection "1" o-- "1" SignalSummaryReporter : uses

    %% Relationships - Services use Repository and State
    SignalQueryService --> SignalRepository : queries
    AlignmentGridService --> SignalRepository : accesses
    EpochGridService --> SignalRepository : accesses
    AlignmentExecutor --> SignalRepository : modifies
    AlignmentExecutor --> AlignmentGridService : uses
    SignalCombinationService --> AlignmentGridState : uses
    SignalCombinationService --> EpochGridState : uses
    OperationExecutor --> EpochGridState : uses
    MetadataManager --> MetadataHandler : uses

    %% Relationships - Services produce State Models
    AlignmentGridService ..> AlignmentGridState : creates
    EpochGridService ..> EpochGridState : creates
    SignalCombinationService ..> CombinationResult : creates

    %% Relationships - Other
    WorkflowExecutor "1" *-- "1" SignalCollection : uses
    SignalCollection ..> FeatureExtraction : uses
    Feature ..> TimeSeriesSignal : derived from
    VisualizerBase ..> TimeSeriesSignal : visualizes
    VisualizerBase ..> Feature : visualizes
    VisualizerBase ..> SignalCollection : visualizes
    RandomForestSleepStaging ..> Feature : processes
    RandomForestSleepStaging ..> Feature : produces
