"""
AlignmentExecutor - Executes grid alignment operations on signals.

This service extracts grid alignment application logic from SignalCollection,
focusing on reindexing signals to a common alignment grid.
"""

import logging
import time
import warnings
from typing import Optional, List
from concurrent.futures import ThreadPoolExecutor, as_completed

from ..repositories.signal_repository import SignalRepository
from .alignment_grid_service import AlignmentGridService
from ...utils.parallel import get_parallel_config

logger = logging.getLogger(__name__)

# Allowed methods for reindexing
ALLOWED_METHODS = ['nearest', 'pad', 'ffill', 'backfill', 'bfill']


class AlignmentExecutor:
    """
    Executes grid alignment operations on signals.

    This service is responsible for applying a pre-calculated alignment grid
    to time-series signals, reindexing them to a common temporal basis.

    The alignment grid must be generated by AlignmentGridService before
    signals can be aligned.

    Attributes:
        repository: SignalRepository for accessing and modifying time-series signals
        alignment_grid_service: AlignmentGridService providing the alignment grid

    Example:
        >>> from src.sleep_analysis.core.repositories import SignalRepository
        >>> from src.sleep_analysis.core.services import AlignmentGridService, AlignmentExecutor
        >>>
        >>> repository = SignalRepository(metadata_handler, "UTC")
        >>> grid_service = AlignmentGridService(repository)
        >>> executor = AlignmentExecutor(repository, grid_service)
        >>>
        >>> # First generate the grid
        >>> grid_service.generate_alignment_grid(target_sample_rate=100.0)
        >>>
        >>> # Then apply alignment to signals
        >>> count = executor.apply_grid_alignment(method='nearest')
        >>> print(f"Aligned {count} signals")
    """

    def __init__(self, repository: SignalRepository, alignment_grid_service: AlignmentGridService):
        """
        Initialize AlignmentExecutor.

        Args:
            repository: SignalRepository instance for accessing time-series signals
            alignment_grid_service: AlignmentGridService instance providing alignment grid
        """
        self.repository = repository
        self.alignment_grid_service = alignment_grid_service

    def apply_grid_alignment(
        self,
        method: str = 'nearest',
        signals_to_align: Optional[List[str]] = None
    ) -> int:
        """
        Apply grid alignment to signals.

        Reindexes specified signals to match the alignment grid calculated by
        the AlignmentGridService. Signals are modified in place.

        Args:
            method: Reindexing method to use. One of:
                - 'nearest': Use nearest neighbor for filling
                - 'pad' / 'ffill': Forward fill from previous values
                - 'backfill' / 'bfill': Backward fill from future values
                Defaults to 'nearest'.
            signals_to_align: Optional list of signal keys to align.
                If None, aligns all time-series signals in the repository.

        Returns:
            Number of successfully aligned signals

        Raises:
            RuntimeError: If alignment grid has not been generated, or if
                         any signals fail to align.

        Example:
            >>> # Align all signals using nearest neighbor
            >>> count = executor.apply_grid_alignment()
            >>>
            >>> # Align specific signals using forward fill
            >>> count = executor.apply_grid_alignment(
            ...     method='ffill',
            ...     signals_to_align=['hr_0', 'ppg_0']
            ... )
        """
        # Validate that grid has been generated
        state = self.alignment_grid_service.state
        if not state.is_valid():
            logger.error("Cannot apply grid alignment: generate_alignment_grid must be run successfully first.")
            raise RuntimeError("generate_alignment_grid must be run successfully before applying grid alignment.")

        # Validate method
        if method not in ALLOWED_METHODS:
            logger.warning(f"Alignment method '{method}' not in allowed list {ALLOWED_METHODS}. Using 'nearest'.")
            method = 'nearest'

        logger.info(f"Applying grid alignment in-place to TimeSeriesSignals using method '{method}'...")
        start_time = time.time()

        # Determine which signals to align
        time_series_signals = self.repository.get_all_time_series()
        target_keys = signals_to_align if signals_to_align is not None else list(time_series_signals.keys())

        processed_count = 0
        skipped_count = 0
        error_signals = []

        # Helper function for aligning a single signal
        def align_signal(key):
            """Align a single signal to the grid."""
            try:
                signal = self.repository.get_time_series_signal(key)

                current_data = signal.get_data()
                if current_data is None or current_data.empty:
                    logger.warning(f"Skipping alignment for TimeSeriesSignal '{key}': data is None or empty.")
                    return 'skipped', key

                logger.debug(f"Applying reindex_to_grid for TimeSeriesSignal '{key}'...")
                signal.apply_operation(
                    'reindex_to_grid',
                    inplace=True,
                    grid_index=state.grid_index,
                    method=method
                )
                logger.debug(f"Successfully aligned TimeSeriesSignal '{key}'.")
                return 'success', key

            except KeyError:
                logger.warning(f"TimeSeriesSignal key '{key}' specified for alignment not found.")
                return 'skipped', key

            except Exception as e:
                logger.error(f"Failed to align TimeSeriesSignal '{key}': {e}", exc_info=True)
                warnings.warn(f"Failed to apply grid alignment to TimeSeriesSignal '{key}': {e}")
                return 'error', key

        # Check if parallel processing should be used
        parallel_config = get_parallel_config()
        use_parallel = parallel_config.enabled and len(target_keys) >= 3

        if use_parallel:
            logger.info(f"Aligning {len(target_keys)} signals in parallel with {parallel_config.max_workers_io} threads")

            with ThreadPoolExecutor(max_workers=parallel_config.max_workers_io) as executor:
                # Submit all alignment tasks
                future_to_key = {executor.submit(align_signal, key): key for key in target_keys}

                # Process results as they complete
                for future in as_completed(future_to_key):
                    status, key = future.result()
                    if status == 'success':
                        processed_count += 1
                    elif status == 'skipped':
                        skipped_count += 1
                    elif status == 'error':
                        error_signals.append(key)
        else:
            # Sequential processing
            for key in target_keys:
                status, returned_key = align_signal(key)
                if status == 'success':
                    processed_count += 1
                elif status == 'skipped':
                    skipped_count += 1
                elif status == 'error':
                    error_signals.append(returned_key)

        elapsed = time.time() - start_time
        logger.info(f"Grid alignment application finished in {elapsed:.2f} seconds. "
                   f"Processed: {processed_count}, Skipped: {skipped_count}, Errors: {len(error_signals)}")

        if error_signals:
            raise RuntimeError(f"Failed to apply grid alignment to the following TimeSeriesSignals: {', '.join(error_signals)}")

        return processed_count
