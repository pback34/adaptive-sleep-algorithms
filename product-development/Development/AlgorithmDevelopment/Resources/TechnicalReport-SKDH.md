# SciKit-Digital-Health: Overview and Sleep Tracking Analysis

## Background of SciKit-Digital-Health (SKDH)

SciKit-Digital-Health (SKDH) is an open-source Python package developed to streamline the processing of wearable sensor data in health research ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=Wearable%20inertial%20sensors%20are%20providing,data%20ingestion%2C%20preprocessing%2C%20and%20data)). It was introduced in 2022 by researchers at Pfizer’s Digital Medicine group to fill a gap in available tools for analyzing daily living activities from raw sensor inputs ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=Wearable%20inertial%20sensors%20are%20providing,sleep%2C%20wrapped%20in%20an%20easily)) ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=offer%20lower%20subject%20burden,19)). Before SKDH, few general-purpose software packages existed for handling signals like accelerometry across various activities (gait, physical activity, sleep) in one framework ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=Wearable%20inertial%20sensors%20are%20providing,data%20ingestion%2C%20preprocessing%2C%20and%20data)). Notably, the R package GGIR provided a collection of algorithms for activity and sleep and became widely used (applied in >90 studies) ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=GGIR%20is%20a%20collection%20of,evaluated%20in%20over%2090%20peer)), but Python equivalents were scarce. SKDH was released under an MIT license to encourage broad use and extension ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=analysis%20methods%20geared%20toward%20modern,health%29%2C%20the)), following a **“convention over configuration”** philosophy – it comes with sensible defaults (based on healthy adult data) to ease use while allowing customization ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=analysis%20methods%20geared%20toward%20modern,health%29%2C%20the)).

In summary, SKDH’s development was motivated by the need for an accessible, unified toolkit for digital health signal processing. By open-sourcing a library that integrates data ingestion, preprocessing, and analysis in a single pipeline, the authors aimed to promote reproducibility and reduce the barrier to applying wearable sensor algorithms in research ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=SciKit%20Digital%20Health%20,a%20convention%20over%20configuration%20approach)).

## Capabilities and Features of SKDH

SKDH provides a comprehensive set of tools for inertial measurement unit (IMU) data (primarily accelerometer-based) analysis ([GitHub - pfizer-opensource/scikit-digital-health: Python package for the processing and analysis of Inertial Measurement Unit Data](https://github.com/pfizer-opensource/scikit-digital-health#:~:text=Scikit%20Digital%20Health%20,analyzing%20wearable%20inertial%20sensor%20data)). Its capabilities span multiple processing stages and clinical endpoints:

- **Data Ingestion**: Utilities to read proprietary binary formats from common research devices (e.g., Axivity .cwa, GENEActiv .bin, ActiGraph files) into Python ([GitHub - pfizer-opensource/scikit-digital-health: Python package for the processing and analysis of Inertial Measurement Unit Data](https://github.com/pfizer-opensource/scikit-digital-health#:~:text=SKDH%20provides%20the%20following%3A)) ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=SKDH%20is%20a%20Python%203,as%20shown%20in%20Textbox%201)). This abstracts away device-specific details and yields a uniform data structure. For example, SKDH can directly import raw acceleration files from Axivity or GENEActiv devices via dedicated readers ([GitHub - pfizer-opensource/scikit-digital-health: Python package for the processing and analysis of Inertial Measurement Unit Data](https://github.com/pfizer-opensource/scikit-digital-health#:~:text=SKDH%20provides%20the%20following%3A)).
- **Preprocessing**: Functions to clean and calibrate raw signals. SKDH implements **autocalibration** methods for accelerometers (following van Hees et al. 2014 ([skdh.sleep.Sleep — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/generated/skdh.sleep.Sleep.html#:~:text=))) so that static gravity equals 1g, as well as wear-time detection algorithms to identify when the device was off-body ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=SKDH%20is%20a%20Python%203,as%20shown%20in%20Textbox%201)). Missing data imputation and filtering (moving averages, etc.) are also provided.
- **Feature Extraction**: A library of common time-series features (statistical and frequency-domain). Developers can compute mean, standard deviation, entropy measures, dominant frequency, etc., through a unified `features.Bank` interface ([SKDH API — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/index.html#:~:text=,35)) ([SKDH API — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/index.html#:~:text=,skdh.features.RangePowerSum)). These features are implemented in optimized C/Fortran for speed ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=SKDH%20also%20contains%20various%20common,Table%201)), making it feasible to process long recordings quickly.
- **Algorithm Modules**: Built-in algorithms for specific health metrics:
    - **Gait analysis** – e.g., detecting steps and calculating gait parameters like stride time, gait speed, and symmetry ([skdh.features.Bank — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/generated/skdh.features.Bank.html#:~:text=,100)) ([skdh.features.Bank — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/generated/skdh.features.Bank.html#:~:text=,112)).
    - **Sit-to-Stand tests** – assessing transition times and postural transfer metrics.
    - **Physical activity** – classifying activity intensity and computing circadian rhythm measures (fragmentation indices, intensity gradients, etc.) ([SKDH API — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/index.html#:~:text=,skdh.activity.metric_mad)).
    - **Sleep analysis** – detecting sleep periods and computing sleep quality metrics (detailed next).
- **Pipeline Architecture**: SKDH uses a pipeline design that allows chaining these steps. All processing algorithms inherit from a base class (`BaseProcess`) and can be linked sequentially in an `skdh.Pipeline` ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=methods%20such%20as%20accelerometer%20calibration%3B,as%20shown%20in%20Textbox%201)). The base class handles common tasks and ensures each module’s output feeds appropriately into the next ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=methods%20such%20as%20accelerometer%20calibration%3B,as%20shown%20in%20Textbox%201)). This design lets users easily construct end-to-end processing flows. For example, _Textbox 1_ of the SKDH documentation shows a simple script adding a file reader, calibration step, and gait analysis to a pipeline, then running them in order ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=,processing%20to%20generate%20gait%20endpoints)) ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=pipeline)). Such modularity means users can mix-and-match provided algorithms or insert custom ones with minimal effort.

**Table 1. Key Features of SciKit-Digital-Health and Comparable Libraries**

|**Library**|**Data Types & Sources**|**Sleep Analysis Approach**|**Other Capabilities**|**Language/License**|
|---|---|---|---|---|
|**SKDH (SciKit-Digital-Health)** ([GitHub - pfizer-opensource/scikit-digital-health: Python package for the processing and analysis of Inertial Measurement Unit Data](https://github.com/pfizer-opensource/scikit-digital-health#:~:text=Scikit%20Digital%20Health%20,analyzing%20wearable%20inertial%20sensor%20data)) ([GitHub - pfizer-opensource/scikit-digital-health: Python package for the processing and analysis of Inertial Measurement Unit Data](https://github.com/pfizer-opensource/scikit-digital-health#:~:text=SKDH%20provides%20the%20following%3A))|Raw accelerometer data (Axivity, GENEActiv, ActiGraph, etc.); supports calibration and wear detection ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=SKDH%20is%20a%20Python%203,as%20shown%20in%20Textbox%201)).|Sleep/wake via filtered activity index + heuristic scoring (Cole-Kripke based) ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=significantly%20improve%20sleep,of%20the%20acceleration%20data)); computes TST, WASO, bouts, fragmentation (Gini index, transition probabilities) ([SKDH API — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/index.html#:~:text=,71)) ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=significantly%20improve%20sleep,of%20the%20acceleration%20data)).|Gait (stride time, gait speed, etc.) ([skdh.features.Bank — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/generated/skdh.features.Bank.html#:~:text=,skdh.gait.DoubleSupport)); Sit-to-stand; Activity intensity & circadian metrics; Extensible pipeline architecture ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=methods%20such%20as%20accelerometer%20calibration%3B,as%20shown%20in%20Textbox%201)).|Python (open-source, MIT) ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=analysis%20methods%20geared%20toward%20modern,health%29%2C%20the)).|
|**SleepPy** ([GitHub - elyiorgos/sleeppy](https://github.com/elyiorgos/sleeppy#:~:text=match%20at%20L270%20,worn%20wearable%20devices%20to)) ([GitHub - elyiorgos/sleeppy](https://github.com/elyiorgos/sleeppy#:~:text=1,hour%20segments%20%28noon%20to%20noon))|Raw wrist accelerometer (designed for GeneActiv .bin or .csv) ([GitHub - elyiorgos/sleeppy](https://github.com/elyiorgos/sleeppy#:~:text=following%20syntax%20will%20run%20,non%20trivial%20amount%20of%20processing)); single-sensor focus.|Multi-step pipeline (day segmentation, activity index, off-body detection, major sleep window, then Cole-Kripke sleep/wake scoring) ([GitHub - elyiorgos/sleeppy](https://github.com/elyiorgos/sleeppy#:~:text=4,for%20each%20day)) ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=The%20sleep%20algorithm%20in%20SKDH,adapted%20into%20the%20SKDH%20framework)). Provides sleep duration, efficiency, etc.|Generates reports and plots automatically ([GitHub - elyiorgos/sleeppy](https://github.com/elyiorgos/sleeppy#:~:text=6,rest%20period%20for%20each%20day)); Modular design but limited to sleep analysis.|Python (open-source, JOSS paper) ([Journal of Open Source Software: SleepPy: A python package for sleep analysis from accelerometer data](https://joss.theoj.org/papers/10.21105/joss.01663#:~:text=Citation)).|
|**pyActigraphy** ([pyActigraphy: Open-source python package for actigraphy data visualization and analysis|PLOS Computational Biology]([https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1009514#:~:text=Over%20the%20past%2040%20years%2C,the%20establishment%20of%20a%20comprehensive](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1009514#:~:text=Over%20the%20past%2040%20years%2C,the%20establishment%20of%20a%20comprehensive))) ([pyActigraphy: Open-source python package for actigraphy data visualization and analysis|PLOS Computational Biology]([https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1009514#:~:text=and%20closed,As](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1009514#:~:text=and%20closed,As)))|Actigraphy data (supports 7 formats: e.g., ActiGraph .gt3x, Actiwatch, GENEActiv) ([pyActigraphy: Open-source python package for actigraphy data visualization and analysis|PLOS Computational Biology]([https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1009514#:~:text=and%20closed,As](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1009514#:~:text=and%20closed,As))); reads both raw and count data (with conversion) ([pyActigraphy: Open-source python package for actigraphy data visualization and analysis|
|**GGIR (R package)** ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=GGIR%20is%20a%20collection%20of,evaluated%20in%20over%2090%20peer)) ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=offer%20lower%20subject%20burden,19))|Raw accelerometer data (Axivity, GENEActiv, ActiGraph, others via CSV); built in R, widely used in large studies.|Sleep period detection using sustained inactivity thresholds (van Hees method) ([skdh.sleep.Sleep — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/generated/skdh.sleep.Sleep.html#:~:text=)); sleep/wake via threshold or machine learned cut-points. Provides comprehensive sleep statistics.|Extensive validation in research (90+ studies) ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=GGIR%20is%20a%20collection%20of,evaluated%20in%20over%2090%20peer)); also computes physical activity metrics.|R (open-source, GPL).|
|**NeuroKit2** (for multi-sensor)**|PPG, ECG, EDA, accelerometer (various sources via array inputs); no specific file readers for wearables.|_No built-in sleep detection_, but can derive heart-rate variability and other physiological features that correlate with sleep stages. Often used alongside actigraphy for multi-sensor analysis.|Rich biosignal processing: ECG peak detection, HRV, respiratory analysis, stress indices. Can be leveraged to extract features (e.g., heart rate dips) for custom sleep models.|Python (open-source, MIT).|

_Table 1:_ Comparison of SKDH with other libraries in the domain. _TST: total sleep time; WASO: wake after sleep onset; PPG: photoplethysmogram; ECG: electrocardiogram; EDA: electrodermal activity._ SKDH and pyActigraphy provide broad toolsets for actigraphy; SleepPy is focused on sleep; GGIR is a well-established R toolkit. NeuroKit2 is included as an example of a physiological signal library that could complement accelerometry in multi-sensor approaches (though it doesn’t itself perform sleep/wake classification).

## Sleep Tracking Algorithm in SKDH

**Sleep Detection in SKDH:** The sleep analysis module of SKDH builds upon prior research and the authors’ earlier SleepPy package ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=)). It uses a two-stage approach:

1. **Sleep Opportunity Window Identification** – For each day (typically using a noon-to-noon period), SKDH identifies the likely major sleep window (the period when the user is presumably in bed attempting to sleep). This is done by analyzing the activity level time-series with moving averages and medians ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=significantly%20improve%20sleep,of%20the%20acceleration%20data)). Essentially, the algorithm looks for a prolonged interval of low movement. By smoothing the acceleration signal and applying adaptive thresholds, it detects one continuous _rest period_ per 24h cycle that qualifies as the primary sleep period ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=significantly%20improve%20sleep,of%20the%20acceleration%20data)). This method is based on the open-access approach by van Hees et al. (2015) to estimate sleep duration from raw wrist accelerometry ([skdh.sleep.Sleep — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/generated/skdh.sleep.Sleep.html#:~:text=)). SKDH’s implementation refines this by also leveraging wear detection (to ensure the device is worn during that period) and ignoring off-wrist time that could falsely appear as “sleep” (an improvement highlighted for more accurate on-body detection) ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=The%20sleep%20algorithm%20in%20SKDH,adapted%20into%20the%20SKDH%20framework)).
    
2. **Epoch-by-Epoch Sleep/Wake Classification** – Within the identified sleep window, SKDH classifies each minute (or epoch) as “sleep” or “wake.” It computes an **activity index** from the raw accelerometer data – a feature that quantifies movement intensity per epoch (inspired by Bai et al. 2016’s activity index for raw acceleration ([skdh.sleep.Sleep — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/generated/skdh.sleep.Sleep.html#:~:text=))). This activity index is then fed into a **heuristic scoring algorithm** derived from the Cole-Kripke model ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=significantly%20improve%20sleep,of%20the%20acceleration%20data)). The Cole-Kripke algorithm (Cole et al., 1992) is a widely used actigraphy method that uses a weighted sum of activity in the surrounding minutes to decide if the current epoch is sleep or wake. SKDH adapts this algorithm to work with raw acceleration signals (after calibration) instead of the traditional “activity counts.” If the activity index is below a certain threshold (meaning little movement), the epoch is classified as _sleep_; if above, as _wake_, with some rules to smooth isolated movements ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=significantly%20improve%20sleep,of%20the%20acceleration%20data)). This yields a minute-by-minute sleep/wake timeline through the night.
    

After classification, SKDH computes a rich set of **sleep metrics** from the binary sleep/wake sequence ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=match%20at%20L404%20and%20then,can%20be%20produced%20as%20well)). These include standard measures like **Total Sleep Time (TST)**, **Sleep Onset Latency** (time to fall asleep), **Wake After Sleep Onset (WASO)** (minutes awake after sleep began), **Sleep Efficiency** (percent of time in bed spent asleep), and **Number of Awakenings** ([SKDH API — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/index.html#:~:text=,69)). It also calculates more advanced analytics, such as the **Sleep and Wake Gini indices** (which measure the inequality of bout lengths as a fragmentation indicator) and **transition probabilities** between sleep and wake ([SKDH API — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/index.html#:~:text=,skdh.sleep.WakePowerLawDistribution)). For example, SKDH can output the probability of transitioning from sleep to wake in any given minute – a high value might indicate fragmented sleep with frequent awakenings ([SKDH API — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/index.html#:~:text=,skdh.sleep.WakeGiniIndex)). These metrics align with those reported in clinical sleep studies and allow quantitative assessment of sleep quality. The library’s design even allows adding custom sleep metrics if needed ([SKDH API — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/index.html#:~:text=,Information)).

Overall, SKDH’s sleep tracking algorithm is a hybrid of established methods: it uses **threshold-based window detection** (as in GGIR’s approach ([skdh.sleep.Sleep — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/generated/skdh.sleep.Sleep.html#:~:text=))) combined with a **validated epoch scoring algorithm (Cole-Kripke)** ([skdh.sleep.Sleep — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/generated/skdh.sleep.Sleep.html#:~:text=)). By default, it standardizes many parameter choices (filter lengths, thresholds) to values suitable for average adults, which simplifies use ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=analysis%20methods%20geared%20toward%20modern,health%29%2C%20the)). However, users can adjust parameters (e.g., minimum sleep duration or sensitivity of the classifier) or even swap in a different algorithm thanks to the modular design. The results have been shown in SKDH’s documentation plots to closely mimic traditional actigraphy outputs ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=and%20then%20applying%20a%20heuristic,can%20be%20produced%20as%20well)), giving confidence in the approach. SKDH essentially encapsulates a best-practice actigraphy sleep analysis pipeline in an open-source implementation.

## Comparison with Alternative Libraries

Several other libraries and tools offer overlapping functionality with SKDH, especially for sleep analysis from wearable sensors. **Table 1** above summarized key comparisons. Below we highlight a few points of differentiation and similarity:

- **SleepPy vs. SKDH**: SleepPy (2019) was an earlier Python package focused solely on sleep from accelerometer data ([GitHub - elyiorgos/sleeppy](https://github.com/elyiorgos/sleeppy#:~:text=match%20at%20L270%20,worn%20wearable%20devices%20to)). In fact, SKDH’s sleep module was directly adapted from SleepPy ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=)). Both follow a multi-step procedure of finding a major rest period then classifying sleep/wake within it. SleepPy’s pipeline consisted of seven clear steps (day segmentation, activity index calculation, non-wear detection, sleep window identification, sleep/wake scoring, metric computation, and report generation) ([GitHub - elyiorgos/sleeppy](https://github.com/elyiorgos/sleeppy#:~:text=4,for%20each%20day)) ([GitHub - elyiorgos/sleeppy](https://github.com/elyiorgos/sleeppy#:~:text=6,rest%20period%20for%20each%20day)). SKDH carries forward this logic but integrates it into a more flexible framework. Unlike SleepPy, which was a stand-alone script-oriented tool, SKDH allows the sleep analysis to be one part of a larger pipeline (e.g., combined with physical activity analysis). Additionally, SKDH expanded on SleepPy by adding more **sleep endpoints** (Gini indices, transition probabilities, etc., some of which were not in the original SleepPy). Essentially, SleepPy can be seen as the progenitor of SKDH’s sleep capabilities ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=)) – SKDH extends it with better integration and additional sensor support (SleepPy was tailored to GeneActiv data, whereas SKDH reads multiple device formats).
    
- **pyActigraphy vs. SKDH**: pyActigraphy is another open-source Python library, introduced in 2021, which specifically targets actigraphy analysis ([pyActigraphy: Open-source python package for actigraphy data visualization and analysis | PLOS Computational Biology](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1009514#:~:text=Over%20the%20past%2040%20years%2C,The%20development%20of)). It overlaps with SKDH in being able to read various wearable data formats and compute sleep metrics. A key difference is in algorithmic flexibility: pyActigraphy implements **multiple published sleep algorithms** (Cole-Kripke, Sadeh, Oakley, etc.) for epoch-by-epoch scoring ([pyActigraphy: Open-source python package for actigraphy data visualization and analysis | PLOS Computational Biology](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1009514#:~:text=The%20pyActigraphy%20package%20implements%20several,classified%20into%20two%20broad%20classes)), as well as methods to detect whole sleep periods in one go (e.g., an algorithm by Roenneberg to find consolidated rest spans) ([pyActigraphy: Open-source python package for actigraphy data visualization and analysis | PLOS Computational Biology](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1009514#:~:text=,each%20period%20classified%20as%20rest)). This gives users the ability to compare algorithms or use alternatives more suited to specific populations (e.g. Sadeh’s algorithm is often used for children). SKDH, by contrast, currently uses one primary algorithm (Cole-Kripke-like) for sleep/wake detection ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=significantly%20improve%20sleep,of%20the%20acceleration%20data)), which was likely chosen for robustness in adults. PyActigraphy also emphasizes **circadian rhythm analysis** – providing metrics like interdaily stability, sleep regularity index, and interactive visualizations of 24-hour activity patterns ([pyActigraphy: Open-source python package for actigraphy data visualization and analysis | PLOS Computational Biology](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1009514#:~:text=match%20at%20L546%20Based%20on,SRI)) – areas beyond the core scope of SKDH. In terms of design, both libraries support multiple file formats and have modular structures, though SKDH’s pipeline (with compiled speed-ups for feature computation) might be more optimized for large datasets ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=SKDH%20also%20contains%20various%20common,Table%201)). Users dealing primarily with actigraphy for sleep might choose pyActigraphy for its algorithm variety and GUI-friendly plotting, while SKDH appeals if one needs an end-to-end pipeline that also covers gait or other endpoints in the same framework.
    
- **Other Tools (GGIR and more)**: In the R ecosystem, **GGIR** has been a gold standard for raw accelerometer analysis ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=GGIR%20is%20a%20collection%20of,evaluated%20in%20over%2090%20peer)). SKDH drew inspiration from GGIR (citing its methods for calibration and sleep detection) ([skdh.sleep.Sleep — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/generated/skdh.sleep.Sleep.html#:~:text=)) ([skdh.sleep.Sleep — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/generated/skdh.sleep.Sleep.html#:~:text=)). Compared to GGIR, SKDH offers similar capabilities (auto-calibration, non-wear detection, sleep period detection, etc.) but in Python, which may integrate better with data science workflows (e.g., Jupyter notebooks, scikit-learn). Another notable tool is the **Digital Biomarker Discovery Pipeline (DBDP)**, an open-source collection of scripts by another research team ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=algorithms%20for%20gait%20,partial%20set%20of%20tools%20with)). However, DBDP is described as a partial toolkit requiring additional preprocessing steps, whereas SKDH aimed to be more streamlined ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=algorithms%20for%20gait%20,partial%20set%20of%20tools%20with)). For multi-sensor data beyond just accelerometers, researchers often rely on specific libraries (e.g., NeuroKit2 for heart rate/ECG or SleepAPI by manufacturers). SKDH does not natively process PPG or ECG, focusing on motion sensors; thus, for heart-rate-based sleep insights one might need to combine SKDH with a physiological signal library.
    

In summary, SKDH stands out by **combining multiple analyses (sleep, activity, gait) under one roof** and by its focus on raw IMU data with built-in preprocessing. Alternative libraries like SleepPy and pyActigraphy are more specialized in sleep, offering either turnkey simplicity (SleepPy’s one-call analysis) or a breadth of algorithms (pyActigraphy). The choice of tool may depend on the use case: SKDH for a comprehensive digital health study where various endpoints are needed, vs. pyActigraphy for in-depth actigraphy algorithm comparisons, or SleepPy for quick analysis of wrist actigraphy with minimal coding. All these tools, being open-source, collectively push the field toward more transparent and reproducible sleep analysis, moving away from proprietary black-box solutions.

# Designing a Flexible and Scalable Sleep Tracking Library

Designing a custom sleep tracking library that is both flexible and scalable involves careful architectural planning. Below, we outline an architecture that meets the specified requirements: multi-sensor fusion, flexible inputs, modular algorithms, standardized data classes, and a dynamic signal/feature bank. We also highlight best practices and methodologies drawn from existing successful tools (like SKDH, pyActigraphy, etc.) to guide the design.

## Architecture Overview

At a high level, the library should process sensor data through a **pipeline of stages**, each stage handling a specific part of the analysis. Multiple sensor streams (e.g., PPG, accelerometer, ECG) are ingested, synchronized, and then subjected to a series of transformations and analyses. The design must emphasize **modularity** (easy to swap or add components) and **extensibility** (support new sensor types or algorithms without breaking the framework). Figure 1 below (textual representation) outlines the flow:

```
[Data Ingestion] -> [Synchronization] -> [Preprocessing] -> [Feature Extraction] 
       -> [Sleep Classification] -> [Sleep Metrics & Output]
```

**Figure 1: Conceptual Pipeline** – Raw data from one or more sensors is read and aligned in time. It then passes through preprocessing (sensor-specific cleaning/calibration), feature extraction (possibly sensor-specific features and fused features), to a sleep classification module that produces sleep/wake predictions. Finally, a metrics module computes summary statistics for output.

Each block in this pipeline corresponds to a module with a well-defined interface. By adhering to common interfaces, modules become interchangeable. For example, the **Sleep Classification** block could use a simple threshold algorithm or a complex machine learning model, as long as each implements a `predict(data)` method that returns sleep/wake labels for each epoch. This mirrors the strategy of SKDH’s BaseProcess pipeline, where each step subclass shares a common structure and can be “chained together as needed” ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=methods%20such%20as%20accelerometer%20calibration%3B,as%20shown%20in%20Textbox%201)).

We will now discuss each component of the architecture and how to implement it:

## Multi-Sensor Fusion and Flexible Input Handling

**Multi-Sensor Support:** The library should accept data from various sensors – accelerometers (for movement), PPG (for heart rate and variability), ECG (heart activity), and potentially others like skin temperature or respiratory sensors. A core challenge is fusing these data streams, which may have different sampling rates and start times. The architecture should include:

- A **Data Synchronization module** that aligns sensor streams on a common timeline. This could involve resampling signals to a common frequency or computing features on a common epoch length (e.g., 1-minute epochs for all sensors). For instance, accelerometer raw data might be aggregated into per-minute activity counts or variance, while PPG is used to compute per-minute heart rate and heart rate variability (HRV). By converting heterogeneous data into a synchronized time-series of features, we simplify downstream processing. Time alignment can be handled by using timestamps and interpolation if needed, or by clock offset calibration if the devices were not hardware-synchronized.
- A **Sensor Fusion strategy** that combines information from multiple sources. This can be as simple as concatenating features from each sensor for classification, or as complex as a model that processes each signal modality separately and then merges insights (e.g., a neural network with separate branches for accelerometer and PPG). The architecture should not hard-code a specific fusion method but allow different fusion approaches. For example, one could implement early fusion (combine raw signals then analyze) or late fusion (analyze each sensor independently into sleep/wake decisions, then combine the decisions).

**Flexible Input Sources:** Supporting various devices and data formats requires an abstraction layer for data input. The library should provide **reader classes** or functions for each common source:

- _File readers_: e.g., `AxivityReader`, `GeneActivReader`, `FitbitReader`, `CustomCSVReader`. Each knows how to parse its format and output a standard internal representation (such as a `SensorData` object).
- _Streaming interface_: optionally support real-time data ingestion from wearable APIs or BLE streams, by designing the input interface to handle both file-based and live data similarly. For instance, a `DataStream` class could continuously feed data into the pipeline in chunks, though initial focus might be on batch (file) processing.

A best practice from existing tools is to implement a **uniform API** for data loading. PyActigraphy, for example, has a uniform API to read multiple actigraphy file types behind a common `read()` function ([Python API Reference — pyActigraphy 1.2.1 documentation](https://ghammad.github.io/pyActigraphy/api.html#:~:text=Python%20API%20Reference%20%E2%80%94%20pyActigraphy,Actiwatch%204%2C%207%2C)). We can adopt a similar approach: a single factory function (or class method) like `DataLoader.from_source(source_type, **kwargs)` that dispatches to the appropriate reader based on file type or device name. This hides the complexity from the user – they just provide a file or device identifier, and the library returns a `DataSet` object containing all sensor data.

**Data Class Structure:** We propose a standardized data structure to hold multi-sensor data once read. For example:

```python
class SensorData:
    def __init__(self):
        self.signals = {}  # dictionary to hold raw or preprocessed signal arrays
        self.meta = {}     # metadata (sampling rates, sensor info, etc.)
        self.timeline = None  # common time base, e.g., array of timestamps or epoch indices

    def add_signal(self, name: str, data: np.ndarray, sampling_rate: float):
        """Add a sensor time series to the dataset."""
        self.signals[name] = data
        self.meta[name] = {"fs": sampling_rate}
```

Upon reading data, the reader would instantiate a `SensorData`, and populate it with entries like `signals["ACC"]` for accelerometer (perhaps a Nx3 array for tri-axial data) and `signals["PPG"]` for photoplethysmogram, along with sampling rate and other info. This unified container is then passed through the pipeline. The **timeline** can be managed in two ways: either converting all signals to the same sampling rate and aligning them in one array (not always feasible if rates differ widely), or storing each signal separately with its timestamp and using the synchronization module to align when needed. A simple approach for sleep analysis is to derive epoch-based features from each signal independently, resulting in a common epoch grid (e.g., per minute), effectively synchronizing via feature time-binning.

## Modular Algorithm Processing Pipeline

The library’s core should allow easy insertion, removal, or replacement of processing modules. Using an object-oriented approach, we can define an abstract base class for any processing module in the pipeline, ensuring each has a standard interface. For example:

```python
class ProcessingModule:
    def process(self, data: SensorData):
        """Process the data in-place or return a result."""
        raise NotImplementedError
```

Specific modules will inherit from this. For instance, `PreprocessAccelerometer(ProcessingModule)` might implement `process()` to apply calibration and bandpass filtering to the accelerometer signal inside the `SensorData`. A `FeatureExtractionModule` might take the cleaned signals and compute features like activity counts, HRV, etc., storing them in a feature bank (described below).

By standardizing the interface, modules can be **chained**. We can create a `Pipeline` class that holds a list of modules:

```python
class Pipeline:
    def __init__(self):
        self.modules = []
    def add_module(self, module: ProcessingModule):
        self.modules.append(module)
    def run(self, data: SensorData):
        for module in self.modules:
            module.process(data)
        return data  # or specific results object
```

This design allows users to configure pipelines programmatically. For example, a user could do:

```python
data = DataLoader.from_source("Axivity", file="subject01.cwa")
pipeline = Pipeline()
pipeline.add_module(AccelerometerPreprocessor())
pipeline.add_module(PPGPreprocessor())
pipeline.add_module(FeatureExtractor(features=["activity_index", "hr_variability"]))
pipeline.add_module(SleepWakeClassifier(model="cole_kripke"))
pipeline.add_module(SleepMetricsComputer())
results = pipeline.run(data)
```

In this pseudocode, each added module knows how to handle the `SensorData`. The **AccelerometerPreprocessor** might calibrate and compute the vector magnitude; **PPGPreprocessor** might filter the PPG and compute heart rate; the **FeatureExtractor** then calculates the chosen features (e.g., activity index from accelerometer, HRV from PPG) and stores them; the **SleepWakeClassifier** applies an algorithm (Cole-Kripke or perhaps a machine learning model) on those features to label each epoch as sleep or wake; finally, **SleepMetricsComputer** aggregates the labeled epochs into summary metrics (TST, etc.). Because each module is independent, we can swap `SleepWakeClassifier` with a different one (say `DeepLearningSleepClassifier`) without affecting other parts, as long as it consumes the same feature inputs.

This modular approach follows the **Pipeline pattern** seen in scikit-learn and SKDH. SKDH’s use of a BaseProcess class, for example, demonstrates how chaining is achieved in practice ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=methods%20such%20as%20accelerometer%20calibration%3B,as%20shown%20in%20Textbox%201)). They were able to integrate new algorithms (even a custom file reader) by subclassing BaseProcess and then simply inserting it into the pipeline ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=methods%20such%20as%20accelerometer%20calibration%3B,as%20shown%20in%20Textbox%201)) ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=,input)). We should emulate this by making our base `ProcessingModule` robust and by handling common concerns there (e.g., logging, error handling, ensuring consistent input/output shapes).

### Integration of Different Models and Algorithms

The library should not assume one specific method for sleep detection. Some users might prefer classical algorithms (threshold-based or Cole-Kripke), while others might want to use machine learning models (e.g., a trained classifier that uses multiple features). To accommodate this:

- Define a **SleepWakeClassifier interface** (subclass of `ProcessingModule`) that all sleep detection algorithms adhere to. For example, it might require a `train(training_data)` method (if using supervised learning) and a `predict(data)` or `process(data)` method for inference.
- Provide a few **built-in algorithm options**, such as:
    - `HeuristicColeKripkeClassifier` – implements the Cole-Kripke weighted moving window rules ([skdh.sleep.Sleep — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/generated/skdh.sleep.Sleep.html#:~:text=Cole%2C%20R,9)) on the accelerometer activity index feature.
    - `ThresholdHRClassifier` – an example that might classify sleep if heart rate drops below a threshold and movement is low (a simple multi-sensor rule-based algorithm).
    - `MachineLearningClassifier` – a wrapper that can load a user-provided model (say a scikit-learn or XGBoost model) which expects certain features and outputs sleep/wake. The module could be configured with the feature names to pull from the feature bank.
    - `DeepLearningClassifier` – (optional) for advanced use, allow plugging a neural network that might take time-series segments (for example, a small CNN or LSTM taking raw signals or sequences of features). This could be handled by a specialized module as well.
- By using polymorphism, the pipeline doesn’t care which classifier it’s running – the interface is consistent. This is analogous to how scikit-learn Pipelines allow different estimators to be swapped in a classification step.

**Example (pseudocode) of a custom classifier integration:**

```python
class XGBSleepClassifier(SleepWakeClassifier):
    def __init__(self, model_file, feature_names):
        self.model = load_xgboost_model(model_file)
        self.features = feature_names
    def process(self, data: SensorData):
        # Assume data.features is a dict of feature arrays per epoch
        X = np.column_stack([data.features[name] for name in self.features])
        preds = self.model.predict(X)  # returns 0/1 for wake/sleep per epoch
        data.predictions = preds
```

The user could then insert `XGBSleepClassifier` into the pipeline after feature extraction, pointing it to use, say, `["activity_index", "heart_rate", "hrv"]` features. This design makes it straightforward to **evaluate different models** on the same input or improve the algorithm over time without redesigning the whole pipeline.

## Standardized Data and Result Formats

As mentioned, a **class-based data format** (like the `SensorData` class) unifies the input-output flow. At each stage, rather than passing around loose numpy arrays or lists, the `SensorData` (or perhaps we call it `SleepDataBatch`) carries everything. This object can be enriched as it moves through modules:

- Initially contains raw signals (e.g., `data.signals["ACC"]`).
- After preprocessing, raw signals might be replaced or complemented with cleaned versions (e.g., `data.signals["ACC_filt"]`).
- After feature extraction, we can introduce a new attribute, say `data.features`, which could be a dictionary of named feature vectors aligned to epochs (e.g., `data.features["activity_index"]` is an array of length N_epochs).
- After classification, we attach `data.predictions` as a series of sleep/wake labels per epoch.
- After metrics computation, we could have `data.sleep_metrics` as a dictionary of summary outcomes (e.g., `{"TST": 7.1 hours, "SleepEfficiency": 90%, ...}`).

Alternatively, the library can define dedicated classes for certain stages: e.g., `SleepResults` class containing the predictions and metrics. However, keeping everything in one class instance can be convenient, as it acts as a context carrying state through the pipeline. This approach is akin to how MNE (an EEG analysis library) carries data in objects or how Pandas DataFrames carry data and can be augmented with new columns.

Using a standardized structure has multiple benefits:

- **Interoperability**: Functions or modules can rely on data being in a known format. For example, a plotting function could accept a `SensorData` and know where to find the sleep/wake predictions to plot them over time.
- **Ease of saving/loading**: The library can provide methods to serialize the `SensorData` (or just the results) to disk (perhaps as JSON or CSV for the metrics, and maybe NPZ for detailed signals) and load them back. This ensures that analysis results can be stored in a consistent way regardless of which algorithms were used.
- **Extension**: If a new sensor is introduced (say, a skin temperature sensor for circadian rhythm), the data class can simply add another entry (e.g., `signals["Temp"]`). The rest of the pipeline can choose to use or ignore it. It doesn’t break the pipeline to have extra data present. This standardization therefore supports scalability to new modalities.

## Dynamic Signal/Feature Bank for Adaptive Processing

The concept of a **"signal bank"** or **"feature bank"** is to maintain a registry of all derived signals and features that are available at any point for use by subsequent algorithms. Rather than hardcoding a fixed set of features, the library can generate features on the fly and make them accessible for classification or further processing.

In practice, we can implement the feature bank as part of our data structure:

- `data.signals` can act as a _signal bank_, containing raw signals and any intermediate signal (for instance, after filtering, one might store `ACC_vector_mag` as a new signal which is the magnitude of the 3-axis accelerometer).
- `data.features` serves as a _feature bank_, holding downsampled or windowed features. This could include the _activity index_ (from accelerometer), _heart rate_ (from PPG), _HRV metrics_ (from PPG or ECG), _respiration rate_ (if from a sensor), etc. Each feature is typically one value per epoch (minute or other epoch length). Some features could also represent summary stats over the whole night (like average HR during sleep), but those might be more relevant as outputs or additional context.

The **dynamic** aspect means features can be added or removed depending on context:

- The library could allow a user to specify which features to compute via a configuration. For example, `FeatureExtractor(features=["activity_index", "ENMO", "heart_rate"])` might compute only those and skip others to save computation.
- If a certain sensor is not present, the feature extractor module can skip related features. E.g., if no PPG signal, it simply doesn’t produce heart_rate/HRV features. The sleep classifier module should be aware of which features it needs and either gracefully handle missing ones or not be used if prerequisites aren’t met. This could be managed by checking `if feature_name not in data.features: compute or raise error`.
- Modules can also decide to derive new signals/features if needed. For instance, a classifier might decide it needs a rolling average of activity or a particular frequency band of heart rate variability – it could either compute it internally or request it. However, a cleaner design is to keep feature computation in the feature modules and not in the classifier.

To implement the **feature bank** concept elegantly, one could create a `FeatureBank` class (similar to SKDH’s `skdh.features.Bank` which collects multiple feature computations ([SKDH API — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/index.html#:~:text=,35))). For example:

```python
class FeatureBank:
    def __init__(self):
        self.values = {}  # {feature_name: np.ndarray}
    def add_feature(self, name, values):
        self.values[name] = values
    def get_feature(self, name):
        return self.values.get(name)
```

Our `FeatureExtractionModule` can utilize a list of feature generator functions or objects. Each feature generator would know how to compute a specific feature from the signals. For instance, an `ActivityIndexFeature` class could take accelerometer data and compute the activity index as defined by Bai et al. (2016) ([skdh.sleep.Sleep — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/generated/skdh.sleep.Sleep.html#:~:text=)) (which might involve filtering the accel signal to 1 Hz and taking the std dev or similar). Likewise, an `HRVFeature` might compute the standard deviation of NN intervals from ECG or PPG. The `FeatureExtractionModule.process()` would iterate through the configured features, compute each, and store them in the `FeatureBank` (which could be an attribute of `SensorData` like `data.features`).

This dynamic bank allows for **adaptive feature selection**. For example, during development or depending on computational constraints, one could toggle features on/off easily. It also fosters experimentation: researchers can plug in a new feature calculation (by adding a new feature class) and add it to the pipeline without rewriting the whole pipeline.

Another advantage is reusability: if multiple classification algorithms require the same intermediate feature, it is computed once and stored in the bank for any to use. For example, **Sleep efficiency** calculation and a **machine learning classifier** might both use the total sleep time in their computations; the feature bank could store an intermediate “sleep_duration” feature after classification that can be reused.

**Adaptive classification** could also be interpreted as the ability to change the algorithm based on available features or sensors. For instance, the library could automatically choose a different sleep detection method if heart rate data is available versus when it’s not. This could be an advanced feature: e.g., default to actigraphy-only method if only ACC is present, but if ACC+PPG present, use a multi-sensor model (since research suggests combining cardiac data improves sleep-wake detection ( [Combining cardiac monitoring with actigraphy aids nocturnal arousal detection during ambulatory sleep assessment in insomnia - PMC](https://pmc.ncbi.nlm.nih.gov/articles/PMC9113014/#:~:text=It%20has%20remained%20challenging%20to,sensitive%20biomarker%20of%20insomnia%20severity) )). Implementing this could be as simple as providing a high-level function that inspects the `SensorData` content and selects a pipeline or classifier accordingly (or a classifier that itself checks `if "heart_rate" in data.features`). However, it’s often better to let users explicitly choose, to maintain transparency.

## Best Practices and Design Considerations

Designing a library of this nature should follow software engineering best practices and learned lessons from existing tools:

- **Modularity and Abstraction:** Embrace object-oriented design to separate concerns. Each module does one thing (e.g., read data, compute a feature, classify sleep) and does it through a clear interface. This is aligned with the **Single Responsibility Principle** and makes testing easier. SKDH’s use of an extensible BaseProcess for each algorithm ensured consistency and easy linkage ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=methods%20such%20as%20accelerometer%20calibration%3B,as%20shown%20in%20Textbox%201)) – new algorithms could be added simply by subclassing, which is a good pattern to follow.
- **Default Conventions with Configurability:** Provide reasonable defaults (as SKDH does with “convention over configuration” ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=analysis%20methods%20geared%20toward%20modern,health%29%2C%20the))) for general users, but allow power users to tweak parameters. For example, the default epoch length might be 60 seconds, but allow it to be changed; default thresholds for sleep detection should suit typical adults, but allow overriding for, say, pediatric use where activity levels differ.
- **Use of Existing Libraries/Methodologies:** Build on proven libraries for signal processing to avoid reinventing the wheel. For instance, numpy/scipy for filters, neurokit or heartpy for heart rate extraction, scikit-learn for implementing machine learning parts. This not only saves time but ensures robustness (e.g., using a well-tested filter function). However, to keep the library lightweight, carefully choose dependencies and possibly make some optional (e.g., only require NeuroKit if using ECG analysis).
- **Performance Optimization:** Processing long-duration signals (many days of data at high sampling rates) can be computationally heavy. Follow SKDH’s example of optimizing critical parts in low-level languages when necessary ([JMIR mHealth and uHealth - SciKit Digital Health: Python Package for Streamlined Wearable Inertial Sensor Data Processing](https://mhealth.jmir.org/2022/4/e36762#:~:text=SKDH%20also%20contains%20various%20common,Table%201)). Vectorize operations with numpy wherever possible instead of Python loops. If certain feature computations are slow in pure Python (like entropy measures or spectral features), consider implementing them in Cython or using numba for JIT compilation. Providing an option to downsample or window data for less precision but more speed is also useful (some users might accept 30s epoch resolution instead of 1s if it runs faster).
- **Memory Management:** Multi-sensor data can be large. The library should process data in streams or chunks when possible, rather than loading everything into memory at once. For example, if analyzing months of data, the pipeline could iterate day by day (similar to SleepPy splitting data by day ([GitHub - elyiorgos/sleeppy](https://github.com/elyiorgos/sleeppy#:~:text=1,hour%20segments%20%28noon%20to%20noon))). Designing the pipeline to handle one day (or one user-session) at a time, output results, then clear data, will make the library scalable to big datasets. The pipeline class might allow resetting or reusing modules on new data sequentially.
- **Validation and Accuracy:** Ensure the algorithms are validated against gold-standard references. For sleep, compare the output against polysomnography or at least against known algorithms on benchmark datasets. Incorporate unit tests (for each module’s functionality) and integration tests (for the whole pipeline on a sample dataset). Many open-source tools gain trust by demonstrating performance similar to known standards (e.g., Cole-Kripke algorithm was validated against PSG in its original paper ([40 years of actigraphy in sleep medicine and current state of the art ...](https://pmc.ncbi.nlm.nih.gov/articles/PMC10039037/#:~:text=,technical%20limitations%2C%20early%20actigraphy))). If including machine learning models, use cross-validation and report standard metrics (sensitivity, specificity, etc.) to users.
- **Documentation and Usability:** Provide clear documentation with examples for different use cases (actigraphy-only, actigraphy + PPG, etc.). Include diagrams of the pipeline (as we conceptually did) so users understand the data flow. A user-friendly API (perhaps a high-level function `analyze_sleep(data, config)`) can be offered that internally builds the pipeline for typical cases, so that novices can get results with one call, whereas advanced users can customize the pipeline as needed. This layered API design is seen in SleepPy (one function call does everything with reports ([GitHub - elyiorgos/sleeppy](https://github.com/elyiorgos/sleeppy#:~:text=SleepPy%20is%20designed%20for%20ease,csv%20version%20where%20possible))) versus SKDH (requires constructing pipeline but offers more flexibility).
- **Community and Extensibility:** Design for extension by others. Encourage users to contribute new feature modules or algorithms by making the process straightforward (e.g., clearly document how to subclass the classifier or how to register a new sensor type). A plugin system or registry could be implemented so that the library can discover new modules without modifying core code (for example, entry points in Python packaging). This way, the library can grow to accommodate new research (like a new algorithm published for circadian rhythm detection) without central maintenance overhead.

Finally, leverage **domain knowledge** and well-established methodologies. For instance, multi-sensor sleep detection can draw on research that shows heart rate trends add value to motion-based detection ( [Combining cardiac monitoring with actigraphy aids nocturnal arousal detection during ambulatory sleep assessment in insomnia - PMC](https://pmc.ncbi.nlm.nih.gov/articles/PMC9113014/#:~:text=It%20has%20remained%20challenging%20to,sensitive%20biomarker%20of%20insomnia%20severity) ). The library could implement a built-in fusion algorithm citing such research, e.g., if elevated heart rate is observed, be cautious in labeling that epoch as sleep even if movement is low ( [Combining cardiac monitoring with actigraphy aids nocturnal arousal detection during ambulatory sleep assessment in insomnia - PMC](https://pmc.ncbi.nlm.nih.gov/articles/PMC9113014/#:~:text=It%20has%20remained%20challenging%20to,sensitive%20biomarker%20of%20insomnia%20severity) ). By grounding the algorithms in published methods (Cole-Kripke for movement, known HRV features for sleep, etc.), we ensure the library’s outputs are interpretable and credible. Each advanced metric or method included (like sleep transition index or Gini index) should trace back to literature (as SKDH cites each of their sleep metrics to scientific articles ([skdh.sleep.Sleep — SciKit-Digital-Health Documentation](https://scikit-digital-health.readthedocs.io/en/latest/ref/generated/skdh.sleep.Sleep.html#:~:text=))), which is a good practice for a scientific library.

## Conclusion

Designing a flexible sleep tracking library involves balancing generality with specificity. By creating a modular pipeline that can ingest **multi-sensor data**, apply appropriate **preprocessing**, extract a rich set of **features** into a dynamic bank, and then perform **sleep classification** with interchangeable algorithms, we achieve both flexibility and scalability. The use of standardized data classes and a signal/feature bank ensures a consistent flow of information and easy extensibility. Borrowing proven ideas from existing projects – such as SKDH’s pipeline and feature modules, pyActigraphy’s multi-format support, and SleepPy’s clear stepwise analysis – accelerates development and reliability. Following software best practices, with attention to performance and user experience, will result in a library that can serve both researchers and developers in the digital health community.

By adhering to these principles, the resulting library would allow, for example, a researcher to plug in a new wrist device’s data and quickly get sleep metrics, or a developer to integrate a sleep analysis feature into a wellness app with confidence in the underlying algorithmic rigor. The modular design means the library can evolve with the science – as new signals (like novel wearable sensors) or new algorithms (like an improved machine learning model for sleep staging) emerge, they can be incorporated as new modules or features in the bank, keeping the tool at the cutting edge of sleep tracking technology.